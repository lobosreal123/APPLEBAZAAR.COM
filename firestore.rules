rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user is admin
    function isAdmin() {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }
    
    // Helper function to check if user is approved
    function isApproved() {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.status == 'approved';
    }
    
    // Helper function to check if user is a participant in a conversation
    function isConversationParticipant(conversationId) {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/conversations/$(conversationId)) &&
        request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
    }
    
    // Helper function to check if user owns a marketplace item
    function ownsMarketplaceItem(itemId) {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/marketplaceItems/$(itemId)) &&
        get(/databases/$(database)/documents/marketplaceItems/$(itemId)).data.sellerId == request.auth.uid;
    }
    
    // Helper function to check if marketplace item is active
    function isActiveMarketplaceItem(itemId) {
      return exists(/databases/$(database)/documents/marketplaceItems/$(itemId)) &&
        get(/databases/$(database)/documents/marketplaceItems/$(itemId)).data.status == 'active';
    }
    
    // ============================================
    // APPLEBAZAAR WEBSITE - PUBLIC STORE CONFIG
    // ============================================
    // Which POS store(s) are shown on the website. Document publicStore/publicStorewebsite:
    // - ownerId (string), storeId (string) for single store; storeIds (array) for multiple stores (same owner).
    // - storeKeys (array of strings): "ownerId_storeId" for multiple owners/stores, e.g. ["uid1_s1","uid2_s2"].
    // Public read on this doc is required so the inventory rule can evaluate get() for visitors.
    match /publicStore/{docId} {
      allow read: if docId == 'publicStorewebsite';
      allow write: if isAdmin();
    }
    
    // ============================================
    // APPLEBAZAAR WEBSITE - ORDERS COLLECTION
    // ============================================
    // Customer orders from the website; users create at checkout and read only their own
    match /orders/{orderId} {
      allow create: if isAuthenticated();
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow update, delete: if isAdmin();
    }
    
    // ============================================
    // USERS COLLECTION
    // ============================================
    match /users/{userId} {
      // PUBLIC READ for user documents (needed for receipt page to get storeName)
      // Receipt page reads user data without authentication for public sharing
      // Only basic info like storeName is exposed, no sensitive data
      allow get: if true;
      
      // Users can read their own document
      allow read: if isAuthenticated() && request.auth.uid == userId;
      
      // Applebazaar: customer order refs for My Orders (list users/{userId}/orderRefs then getDoc each websiteOrder)
      match /orderRefs/{refId} {
        allow get, list, create, update, delete: if isAuthenticated() && request.auth.uid == userId;
      }
      
      // Allow admins to read ALL user documents (for user management)
      allow read: if isAdmin();
      
      // Allow unauthenticated users to query users by email (for login validation)
      // This is needed to check account status/expiration BEFORE signing in
      // Note: Firestore rules cannot check query filters directly, so we allow all list queries
      // The application code only queries by email when unauthenticated
      // Authenticated users can query all users (for admin/messaging features)
      allow list: if true;
      
      // Note: While this allows unauthenticated list queries, the application code:
      // - Only queries by email for login pre-check (specific user lookup)
      // - Requires authentication for getAllUsers() functions (admin/messaging)
      // - Individual document reads are controlled by allow get/read rules above
      
      // Users can update their own document (but cannot change role or status)
      allow update: if isAuthenticated() && 
                     request.auth.uid == userId &&
                     (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'status']));
      
      // Allow creating user documents - only for new users (first-time creation during registration)
      allow create: if isAuthenticated() && 
                     request.auth.uid == userId &&
                     !exists(/databases/$(database)/documents/users/$(userId));
      
      // Allow admins to update ANY user document (for expiration dates, approve/reject, balance management, etc.)
      allow update: if isAdmin();
      
      // Allow Telegram webhook to update user status (via REST API with API key)
      // This allows the webhook to approve/reject users without Firebase Auth
      // Security: Only allows updates to status, approvedAt, and approvedBy fields
      // The webhook uses Firebase REST API which doesn't provide request.auth
      // Note: For production, consider using Firebase Admin SDK with service account instead
      allow update: if !isAuthenticated() && 
                     // Only allow updates to specific fields (status, approvedAt, approvedBy)
                     request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'approvedAt', 'approvedBy']) &&
                     // Ensure status is a valid value (approved, rejected, or pending)
                     (request.resource.data.status == 'approved' || 
                      request.resource.data.status == 'rejected' || 
                      request.resource.data.status == 'pending');
      
      // Allow admins to delete user documents
      // Note: Application code enforces that only main admin can actually delete
      allow delete: if isAdmin();
      
      // ============================================
      // USER SUBCOLLECTIONS
      // ============================================
      
      // Stores subcollection
      match /stores/{storeId} {
        // Users can only access their own stores
        allow read, write: if isAuthenticated() && request.auth.uid == userId;
        
        // PUBLIC READ for receipts (Receipt.jsx reads without auth)
        // This allows sharing receipt links
        allow read: if true;
      }
      
      // Inventory subcollection (nested under stores)
      // Owner can read/write. Public read allowed for store(s) in website config (publicStore/publicStorewebsite).
      // Config: ownerId+storeId/storeIds (single owner) OR storeKeys (array of "ownerId_storeId") for multiple owners.
      match /stores/{storeId}/inventory/{itemId} {
        allow read: if (isAuthenticated() && request.auth.uid == userId) ||
          (exists(/databases/$(database)/documents/publicStore/publicStorewebsite) &&
           (('storeKeys' in get(/databases/$(database)/documents/publicStore/publicStorewebsite).data && (userId + '_' + storeId) in get(/databases/$(database)/documents/publicStore/publicStorewebsite).data.storeKeys) ||
            (get(/databases/$(database)/documents/publicStore/publicStorewebsite).data.ownerId == userId && (get(/databases/$(database)/documents/publicStore/publicStorewebsite).data.storeId == storeId || ('storeIds' in get(/databases/$(database)/documents/publicStore/publicStorewebsite).data && storeId in get(/databases/$(database)/documents/publicStore/publicStorewebsite).data.storeIds)))));
        allow write: if isAuthenticated() && request.auth.uid == userId;
      }
      
      // Sales subcollection (nested under stores)
      match /stores/{storeId}/sales/{saleId} {
        // Users can read/write their own sales
        allow read, write: if isAuthenticated() && request.auth.uid == userId;
        
        // PUBLIC READ for receipts (Receipt.jsx reads without auth)
        // This allows sharing receipt links
        allow read: if true;
      }
      
      // Customers subcollection (nested under stores)
      match /stores/{storeId}/customers/{customerId} {
        allow read, write: if isAuthenticated() && request.auth.uid == userId;
      }
      
      // Website orders (Applebazaar): online orders from website â†’ POS at users/{userId}/stores/{storeId}/websiteOrders
      // Website can create (unauthenticated); store owner read/update/delete; customer can read own (My Orders getDoc)
      match /stores/{storeId}/websiteOrders/{orderId} {
        allow create: if true;
        allow get, list: if isAuthenticated() && (request.auth.uid == userId || resource.data.customerId == request.auth.uid);
        allow update, delete: if isAuthenticated() && request.auth.uid == userId;
      }
      
      // Settings subcollection
      match /settings/{settingId} {
        // PUBLIC READ for app settings (needed for receipts)
        // This allows receipt page to read settings without auth
        allow get: if settingId == 'app';
        
        // Users can read/write their own settings
        allow read, write: if isAuthenticated() && request.auth.uid == userId;
      }
      
      // Catch-all for any other subcollections
      match /{document=**} {
        allow read, write: if isAuthenticated() && request.auth.uid == userId;
      }
    }
    
    // ============================================
    // CONVERSATIONS COLLECTION (Messaging)
    // ============================================
    match /conversations/{conversationId} {
      // Participants can read and update their conversations
      allow read, update: if isConversationParticipant(conversationId);
      
      // Allow authenticated users to list conversations
      // The query filter (where('participants', 'array-contains', userId)) ensures
      // only conversations where user is a participant are returned
      // Each document is still checked by the read rule above for security
      allow list: if isAuthenticated();
      
      // Participants can create conversations (they become participants)
      allow create: if isAuthenticated() && 
                     request.auth.uid in request.resource.data.participants;
      
      // Messages subcollection
      match /messages/{messageId} {
        // Participants can read messages in their conversations
        allow read: if isConversationParticipant(conversationId);
        
        // Authenticated users who are participants can create messages
        allow create: if isAuthenticated() && 
                       isConversationParticipant(conversationId) &&
                       request.resource.data.senderId == request.auth.uid;
        
        // Sender can update their own messages (for read status, etc.)
        allow update: if isAuthenticated() && 
                       isConversationParticipant(conversationId) &&
                       (resource.data.senderId == request.auth.uid ||
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']));
      }
    }
    
    // ============================================
    // SETTINGS COLLECTION (Global Settings)
    // ============================================
    match /settings/{settingId} {
      // Allow reading telegram settings for notifications (unauthenticated access needed)
      // This is safe because bot token and chat ID are not sensitive for reading
      allow read: if settingId == 'telegram';
      
      // Only admins can write settings
      allow write: if isAdmin();
    }
    
    // ============================================
    // MARKETPLACE ITEMS COLLECTION
    // ============================================
    match /marketplaceItems/{itemId} {
      // Public read for active items (anyone can view marketplace)
      // Also allow owners to read their own items (even if not active)
      allow read: if isActiveMarketplaceItem(itemId) || 
                   (isAuthenticated() && ownsMarketplaceItem(itemId));
      
      // Authenticated users can create items
      // Must set themselves as sellerId
      allow create: if isAuthenticated() && 
                      request.resource.data.sellerId == request.auth.uid;
      
      // Item owners can update their items
      allow update: if ownsMarketplaceItem(itemId);
      
      // Item owners can delete their items
      allow delete: if ownsMarketplaceItem(itemId);
      
      // Allow queries for active items (needed for marketplace listing)
      // Public listing, but filter by status in query
      allow list: if true;
    }
    
    // ============================================
    // IMEI PRICING COLLECTION
    // ============================================
    match /imeiPricing/{document} {
      // PUBLIC READ for config document (needed for Free Check feature on login page)
      // This allows unauthenticated users to see which services are available for Free Check
      // Only the config document is publicly readable, not user-specific data
      allow read: if document == 'config' || isAuthenticated();
      
      // Only admins can write/update pricing (to set custom prices)
      allow write: if isAdmin();
    }
    
    // ============================================
    // EXCHANGE RATES COLLECTION
    // ============================================
    match /exchangeRates/{document} {
      // PUBLIC READ for exchange rates (needed for currency exchange on login page)
      // This allows unauthenticated visitors to see exchange rates and convert currencies
      // Only the config document is publicly readable
      allow read: if document == 'config' || isAuthenticated();
      
      // Only admins can write/update exchange rates (to set currency rates and visibility)
      allow write: if isAdmin();
    }
    
    // ============================================
    // EXCHANGE ORDERS COLLECTION
    // ============================================
    match /exchangeOrders/{orderId} {
      // Allow anyone to create orders (for public order placement)
      // This allows unauthenticated users to place exchange orders from the login page
      allow create: if true;
      
      // Allow public read access to individual orders (for order tracking by order ID)
      // This allows users to track their orders using the order ID
      allow get: if true;
      
      // Only admins can list all orders (for order management in Exchange admin page)
      allow list: if isAdmin();
      
      // Admins can update orders (dashboard). Unauthenticated update allowed for Telegram bot
      // webhook (server-side PHP has no Firebase Auth; bot confirms payment / marks delivered).
      allow update: if isAdmin() || request.auth == null;
      
      // Only admins can delete orders
      allow delete: if isAdmin();
    }
    
    // ============================================
    // EXCHANGE ORDER COUNTERS COLLECTION
    // ============================================
    match /exchangeOrderCounters/{monthKey} {
      // Allow anyone to read/write counters (needed for order number generation)
      // This is safe because transactions ensure atomic increments
      allow read, write: if true;
    }
    
    // ============================================
    // INVENTORY TRANSFERS (POS: shop-to-shop with admin confirmation)
    // ============================================
    // One admin sends a transfer; another admin (by uid or email) confirms and receives.
    // Schema: fromUid, fromStoreId, toUid, toEmail?, toStoreId, items[{inventoryDocId,name,quantity}],
    //         status:'pending'|'accepted'|'rejected', createdAt, respondedAt?, respondedBy?
    match /inventoryTransfers/{transferId} {
      // Create: only admin, and must be sender (fromUid == self), status must be pending
      allow create: if isAdmin() &&
        request.resource.data.fromUid == request.auth.uid &&
        request.resource.data.status == 'pending';
      // Read/list: sender or receiver (by uid or email)
      allow read, list: if isAdmin() && (
        resource.data.fromUid == request.auth.uid ||
        resource.data.toUid == request.auth.uid ||
        (resource.data.toEmail != null && request.auth.token.email != null && resource.data.toEmail == request.auth.token.email)
      );
      // Update: only receiver can update; only pending transfers; only status, respondedAt, respondedBy
      allow update: if isAdmin() &&
        resource.data.status == 'pending' &&
        (resource.data.toUid == request.auth.uid ||
         (resource.data.toEmail != null && request.auth.token.email != null && resource.data.toEmail == request.auth.token.email)) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'respondedAt', 'respondedBy']) &&
        request.resource.data.status in ['accepted', 'rejected'];
      allow delete: if false;
    }
  }
}
